[
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "scipy.integrate",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "scipy.integrate",
        "description": "scipy.integrate",
        "detail": "scipy.integrate",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "_optimcut",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "_optimcut",
        "description": "_optimcut",
        "detail": "_optimcut",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "matplotlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib",
        "description": "matplotlib",
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "distutils.extension",
        "description": "distutils.extension",
        "isExtraImport": true,
        "detail": "distutils.extension",
        "documentation": {}
    },
    {
        "label": "build_ext",
        "importPath": "Cython.Distutils",
        "description": "Cython.Distutils",
        "isExtraImport": true,
        "detail": "Cython.Distutils",
        "documentation": {}
    },
    {
        "label": "Cython.Compiler.Options",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "Cython.Compiler.Options",
        "description": "Cython.Compiler.Options",
        "detail": "Cython.Compiler.Options",
        "documentation": {}
    },
    {
        "label": "cythonize",
        "importPath": "Cython.Build",
        "description": "Cython.Build",
        "isExtraImport": true,
        "detail": "Cython.Build",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "material_length",
        "kind": 5,
        "importPath": "bigger_Example",
        "description": "bigger_Example",
        "peekOfCode": "material_length = np.zeros_like(state)+1000; material_length[0] = 1000;\n#_optimcut.initialize_qrng()\ncopt = _optimcut.CutOptimizer(state,material_length)\nprint(' material lengths: ',copt.material_length)\nprint(' initial state:    ',copt.state)\nsaves, costfs = copt.make_iterations(_state=state,py_niter=10000,py_temp=100,save_states=True)\nmaterial_ids[:] = _optimcut.material_ids_from_saves(saves, material_length)\n#_optimcut.finalize_qrng()",
        "detail": "bigger_Example",
        "documentation": {}
    },
    {
        "label": "copt",
        "kind": 5,
        "importPath": "bigger_Example",
        "description": "bigger_Example",
        "peekOfCode": "copt = _optimcut.CutOptimizer(state,material_length)\nprint(' material lengths: ',copt.material_length)\nprint(' initial state:    ',copt.state)\nsaves, costfs = copt.make_iterations(_state=state,py_niter=10000,py_temp=100,save_states=True)\nmaterial_ids[:] = _optimcut.material_ids_from_saves(saves, material_length)\n#_optimcut.finalize_qrng()",
        "detail": "bigger_Example",
        "documentation": {}
    },
    {
        "label": "material_ids[:]",
        "kind": 5,
        "importPath": "bigger_Example",
        "description": "bigger_Example",
        "peekOfCode": "material_ids[:] = _optimcut.material_ids_from_saves(saves, material_length)\n#_optimcut.finalize_qrng()",
        "detail": "bigger_Example",
        "documentation": {}
    },
    {
        "label": "draw_",
        "kind": 2,
        "importPath": "optimcut",
        "description": "optimcut",
        "peekOfCode": "def draw_(order, material_id, material_length):\n  fig, ax = plt.subplots()\n  ax.set_xlim([0, max( [material_id.max()+2,5] )])\n  _,occ = np. unique(material_id, return_counts=True)\n  #cmap = cm.get_cmap('viridis', int(material_length.max())+1)\n  cmap = mpl.colormaps['viridis']\n  norm = mpl.colors.Normalize(vmin=0, vmax=int(material_length.max())+1)\n  for uid in np.unique(material_id):\n    bottom=0\n    order_id = order[material_id==uid]",
        "detail": "optimcut",
        "documentation": {}
    },
    {
        "label": "cuts_to_material",
        "kind": 2,
        "importPath": "optimcut",
        "description": "optimcut",
        "peekOfCode": "def cuts_to_material(order, material_length):\n  material_id      = np.empty(order.size,dtype=np.int32)\n  current_length   = 0.0\n  current_material = 0\n  for it,slice in enumerate(order):\n    current_length += slice\n    if (current_length > material_length[current_material]):\n      current_length = slice\n      current_material += 1\n    material_id[it] = current_material",
        "detail": "optimcut",
        "documentation": {}
    },
    {
        "label": "material_leftovers",
        "kind": 2,
        "importPath": "optimcut",
        "description": "optimcut",
        "peekOfCode": "def material_leftovers(order, material_id, material_length):\n  leftovers = np.zeros( np.max(material_id)+1 )\n  for material in np.unique(material_id):\n    leftovers[material] = material_length[material] -              \\\n                          np.sum( order[material_id == material] )\n  return leftovers\ndef swap_order(order):\n  n = order.size\n  i = np.random.randint(n)\n  j = np.random.randint(n)",
        "detail": "optimcut",
        "documentation": {}
    },
    {
        "label": "swap_order",
        "kind": 2,
        "importPath": "optimcut",
        "description": "optimcut",
        "peekOfCode": "def swap_order(order):\n  n = order.size\n  i = np.random.randint(n)\n  j = np.random.randint(n)\n  while ((i == j) or (order[i] == order[j])):\n    j = np.random.randint(n)\n  new_order = np.copy(order)\n  new_order[i]  = order[j]\n  new_order[j]  = order[i]\n  return new_order",
        "detail": "optimcut",
        "documentation": {}
    },
    {
        "label": "cost_function",
        "kind": 2,
        "importPath": "optimcut",
        "description": "optimcut",
        "peekOfCode": "def cost_function(order,material_id, material_length):\n  leftovers = material_leftovers(order, material_id, material_length)\n  #n_materials = material_id.max()\n  return leftovers.sum() #+ leftovers.mean()*n_materials\ndef acceptance_probability(order,material_id, new_order,new_material_id, material_length, temp=1.0):\n  return np.exp( (cost_function(order,     material_id,     material_length) - \\\n                  cost_function(new_order, new_material_id, material_length)) / temp )\ndef step(order, material_id, material_length, temp=1.0, verbose=0):\n  #new_order = order.copy()\n  ap = 0.0",
        "detail": "optimcut",
        "documentation": {}
    },
    {
        "label": "acceptance_probability",
        "kind": 2,
        "importPath": "optimcut",
        "description": "optimcut",
        "peekOfCode": "def acceptance_probability(order,material_id, new_order,new_material_id, material_length, temp=1.0):\n  return np.exp( (cost_function(order,     material_id,     material_length) - \\\n                  cost_function(new_order, new_material_id, material_length)) / temp )\ndef step(order, material_id, material_length, temp=1.0, verbose=0):\n  #new_order = order.copy()\n  ap = 0.0\n  while( (ap == 0.0) or (ap < np.random.rand()) ):\n    new_order       = swap_order(order)\n    new_material_id = cuts_to_material(new_order, material_length)\n    ap = acceptance_probability(order,material_id, new_order,new_material_id, material_length, temp=temp)",
        "detail": "optimcut",
        "documentation": {}
    },
    {
        "label": "step",
        "kind": 2,
        "importPath": "optimcut",
        "description": "optimcut",
        "peekOfCode": "def step(order, material_id, material_length, temp=1.0, verbose=0):\n  #new_order = order.copy()\n  ap = 0.0\n  while( (ap == 0.0) or (ap < np.random.rand()) ):\n    new_order       = swap_order(order)\n    new_material_id = cuts_to_material(new_order, material_length)\n    ap = acceptance_probability(order,material_id, new_order,new_material_id, material_length, temp=temp)\n  if (verbose > 0):\n    print(new_order, new_material_id,\n          cost_function(new_order, new_material_id, material_length))",
        "detail": "optimcut",
        "documentation": {}
    },
    {
        "label": "Cython.Compiler.Options.annotate",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "Cython.Compiler.Options.annotate = True\nfrom Cython.Build import cythonize\n\"\"\"\nusage: python setup.py build_ext --inplace\n       python setup.py install --user\n\"\"\"\nprint('Compiling for')\nprint(sys.version)\nprint()\next_modules = [",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "ext_modules",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "ext_modules = [\n    Extension( '_optimcut',\n               sources             = ['_optimcut.pyx'],\n               language            = 'c++',\n               include_dirs        = [numpy.get_include(),'.'],\n               extra_compile_args  = ['-std=c++11','-fopenmp','-pthread','-fPIC','-mtune=native','-march=native','-O3'],\n               extra_link_args     = ['-fopenmp','-pthread'],\n               libraries           = ['gsl','gslcblas','gomp','m'],\n               library_dirs        = ['/usr/local/lib'],\n               define_macros       = [(\"NPY_NO_DEPRECATED_API\", \"NPY_1_7_API_VERSION\")] ),",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "srcfile",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "srcfile = 'build/lib.linux-x86_64-2.7/_optimcut.so'\ndstfile = './_optimcut.so'\nassert not os.path.isabs(srcfile)\nshutil.copy(srcfile, dstfile)\nshutil.rmtree('build')\n\"\"\"",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "dstfile",
        "kind": 5,
        "importPath": "setup",
        "description": "setup",
        "peekOfCode": "dstfile = './_optimcut.so'\nassert not os.path.isabs(srcfile)\nshutil.copy(srcfile, dstfile)\nshutil.rmtree('build')\n\"\"\"",
        "detail": "setup",
        "documentation": {}
    },
    {
        "label": "test_swap_order",
        "kind": 2,
        "importPath": "test_optimcut",
        "description": "test_optimcut",
        "peekOfCode": "def test_swap_order():\n    x = state.copy()\n    _optimcut.swap_order(x,testing=True) # NOTE: for testing this function always uses \n                                         #       the beginig of quasirandom sequence\n    result = np.array([1.0, 5.0, 3.0, 4.0, 2.0], dtype=np.float64, order='C') # expected result\n    assert np.allclose(x,result)\n@pytest.mark.single_function\ndef test_double_swap():\n    x = state.copy()\n    y = x.copy()",
        "detail": "test_optimcut",
        "documentation": {}
    },
    {
        "label": "test_double_swap",
        "kind": 2,
        "importPath": "test_optimcut",
        "description": "test_optimcut",
        "peekOfCode": "def test_double_swap():\n    x = state.copy()\n    y = x.copy()\n    _optimcut.swap_order(x,testing=True) # NOTE: for testing this function always uses \n                                         #       the beginig of quasirandom sequence.\n    _optimcut.swap_order(x,testing=True) # NOTE: double swap of same indices returns to\n                                         #       the orginal variable\n    assert np.allclose(x,y)\n@pytest.mark.single_function\ndef test_cuts_to_material():",
        "detail": "test_optimcut",
        "documentation": {}
    },
    {
        "label": "test_cuts_to_material",
        "kind": 2,
        "importPath": "test_optimcut",
        "description": "test_optimcut",
        "peekOfCode": "def test_cuts_to_material():\n    x = material_id.copy()\n    _optimcut.cuts_to_material(state, x, material_length, testing=True)\n    result = np.array([0,0,1,2,3], dtype=np.int32, order='C')\n    assert np.all( x == result )\n@pytest.mark.single_function\ndef test_leftovers():\n    _optimcut.cuts_to_material(state, material_id, material_length, testing=True)\n    _optimcut.material_leftovers(state, material_id, material_length, leftovers, testing=True)\n    result = np.array([2.0, 2.0, 1.0, 0.0, 0.0,], dtype=np.float64, order='C') # expected result",
        "detail": "test_optimcut",
        "documentation": {}
    },
    {
        "label": "test_leftovers",
        "kind": 2,
        "importPath": "test_optimcut",
        "description": "test_optimcut",
        "peekOfCode": "def test_leftovers():\n    _optimcut.cuts_to_material(state, material_id, material_length, testing=True)\n    _optimcut.material_leftovers(state, material_id, material_length, leftovers, testing=True)\n    result = np.array([2.0, 2.0, 1.0, 0.0, 0.0,], dtype=np.float64, order='C') # expected result\n    assert np.allclose(leftovers,result)\nif __name__ == '__main__':\n    x = np.array([1.0,2.0,3.0,4.0,5.0], dtype=np.float64, order='C')\n    print('# Double swap order test')\n    print(x)\n    _optimcut.swap_order(x,testing=True)",
        "detail": "test_optimcut",
        "documentation": {}
    },
    {
        "label": "material_length",
        "kind": 5,
        "importPath": "test_optimcut",
        "description": "test_optimcut",
        "peekOfCode": "material_length = np.array([5.0,5.0,5.0,5.0,5.0], dtype=np.float64, order='C')\nleftovers       = np.array([0.0,0.0,0.0,0.0,0.0], dtype=np.float64, order='C')\n@pytest.mark.single_function\ndef test_swap_order():\n    x = state.copy()\n    _optimcut.swap_order(x,testing=True) # NOTE: for testing this function always uses \n                                         #       the beginig of quasirandom sequence\n    result = np.array([1.0, 5.0, 3.0, 4.0, 2.0], dtype=np.float64, order='C') # expected result\n    assert np.allclose(x,result)\n@pytest.mark.single_function",
        "detail": "test_optimcut",
        "documentation": {}
    }
]